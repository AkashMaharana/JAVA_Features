1
About This E-Book
EPUB is an open, industry-standard format for e-books. However, support
for EPUB and its many features varies across reading devices and
applications. Use your device or app settings to customize the presentation to
your liking. Settings that you can customize often include font, font size,
single or double column, landscape or portrait mode, and figures that you can
click or tap to enlarge. For additional information about the settings and
features on your reading device or app, visit the device manufacturer’s Web
site.
Many titles include programming code or configuration examples. To
optimize the presentation of these elements, view the e-book in singlecolumn, landscape mode and adjust the font size to the smallest setting. In
addition to presenting code and configurations in the reflowable text format,
we have included images of the code that mimic the presentation found in the
print book; therefore, where the reflowable format may compromise the
presentation of the code listing, you will see a “Click here to view code
image” link. Click the link to view the print-fidelity code image. To return to
the previous page viewed, click the Back button on your device or app.
2
Effective Java
Third Edition
Joshua Bloch
Boston • Columbus • Indianapolis • New York • San Francisco • Amsterdam •
Cape Town
Dubai • London • Madrid • Milan • Munich • Paris • Montreal • Toronto •
Delhi • Mexico City
São Paulo • Sydney • Hong Kong • Seoul • Singapore • Taipei • Tokyo
3
Many of the designations used by manufacturers and sellers to distinguish
their products are claimed as trademarks. Where those designations appear in
this book, and the publisher was aware of a trademark claim, the designations
have been printed with initial capital letters or in all capitals.
The author and publisher have taken care in the preparation of this book, but
make no expressed or implied warranty of any kind and assume no
responsibility for errors or omissions. No liability is assumed for incidental or
consequential damages in connection with or arising out of the use of the
information or programs contained herein.
For information about buying this title in bulk quantities, or for special sales
opportunities (which may include electronic versions; custom cover designs;
and content particular to your business, training goals, marketing focus, or
branding interests), please contact our corporate sales department at
corpsales@pearsoned.com or (800) 382-3419.
For government sales inquiries, please contact
governmentsales@pearsoned.com.
For questions about sales outside the U.S., please contact
intlcs@pearson.com.
Visit us on the Web: informit.com/aw
Library of Congress Control Number: 2017956176
Copyright © 2018 Pearson Education Inc.
Portions copyright © 2001-2008 Oracle and/or its affiliates.
All Rights Reserved.
All rights reserved. Printed in the United States of America. This publication
is protected by copyright, and permission must be obtained from the publisher
prior to any prohibited reproduction, storage in a retrieval system, or
transmission in any form or by any means, electronic, mechanical,
photocopying, recording, or likewise. For information regarding permissions,
request forms and the appropriate contacts within the Pearson Education
Global Rights & Permissions Department, please visit
www.pearsoned.com/permissions/.
ISBN-13: 978-0-13-468599-1
ISBN-10: 0-13-468599-7
1 17
4
To my family: Cindy, Tim, and Matt
5
Contents
Foreword
Preface
Acknowledgments
1 Introduction
2 Creating and Destroying Objects
Item 1: Consider static factory methods instead of constructors
Item 2: Consider a builder when faced with many constructor parameters
Item 3: Enforce the singleton property with a private constructor or an
enum type
Item 4: Enforce noninstantiability with a private constructor
Item 5: Prefer dependency injection to hardwiring resources
Item 6: Avoid creating unnecessary objects
Item 7: Eliminate obsolete object references
Item 8: Avoid finalizers and cleaners
Item 9: Prefer try-with-resources to try-finally
3 Methods Common to All Objects
Item 10: Obey the general contract when overriding equals
Item 11: Always override hashCode when you override equals
Item 12: Always override toString
Item 13: Override clone judiciously
Item 14: Consider implementing Comparable
4 Classes and Interfaces
Item 15: Minimize the accessibility of classes and members
Item 16: In public classes, use accessor methods, not public fields
Item 17: Minimize mutability
Item 18: Favor composition over inheritance
Item 19: Design and document for inheritance or else prohibit it
Item 20: Prefer interfaces to abstract classes
Item 21: Design interfaces for posterity
Item 22: Use interfaces only to define types
Item 23: Prefer class hierarchies to tagged classes
Item 24: Favor static member classes over nonstatic
Item 25: Limit source files to a single top-level class
6
5 Generics
Item 26: Don’t use raw types
Item 27: Eliminate unchecked warnings
Item 28: Prefer lists to arrays
Item 29: Favor generic types
Item 30: Favor generic methods
Item 31: Use bounded wildcards to increase API flexibility
Item 32: Combine generics and varargs judiciously
Item 33: Consider typesafe heterogeneous containers
6 Enums and Annotations
Item 34: Use enums instead of int constants
Item 35: Use instance fields instead of ordinals
Item 36: Use EnumSet instead of bit fields
Item 37: Use EnumMap instead of ordinal indexing
Item 38: Emulate extensible enums with interfaces
Item 39: Prefer annotations to naming patterns
Item 40: Consistently use the Override annotation
Item 41: Use marker interfaces to define types
7 Lambdas and Streams
Item 42: Prefer lambdas to anonymous classes
Item 43: Prefer method references to lambdas
Item 44: Favor the use of standard functional interfaces
Item 45: Use streams judiciously
Item 46: Prefer side-effect-free functions in streams
Item 47: Prefer Collection to Stream as a return type
Item 48: Use caution when making streams parallel
8 Methods
Item 49: Check parameters for validity
Item 50: Make defensive copies when needed
Item 51: Design method signatures carefully
Item 52: Use overloading judiciously
Item 53: Use varargs judiciously
Item 54: Return empty collections or arrays, not nulls
Item 55: Return optionals judiciously
Item 56: Write doc comments for all exposed API elements
9 General Programming
Item 57: Minimize the scope of local variables
Item 58: Prefer for-each loops to traditional for loops
7
Item 59: Know and use the libraries
Item 60: Avoid float and double if exact answers are required
Item 61: Prefer primitive types to boxed primitives
Item 62: Avoid strings where other types are more appropriate
Item 63: Beware the performance of string concatenation
Item 64: Refer to objects by their interfaces
Item 65: Prefer interfaces to reflection
Item 66: Use native methods judiciously
Item 67: Optimize judiciously
Item 68: Adhere to generally accepted naming conventions
10 Exceptions
Item 69: Use exceptions only for exceptional conditions
Item 70: Use checked exceptions for recoverable conditions and runtime
exceptions for programming errors
Item 71: Avoid unnecessary use of checked exceptions
Item 72: Favor the use of standard exceptions
Item 73: Throw exceptions appropriate to the abstraction
Item 74: Document all exceptions thrown by each method
Item 75: Include failure-capture information in detail messages
Item 76: Strive for failure atomicity
Item 77: Don’t ignore exceptions
11 Concurrency
Item 78: Synchronize access to shared mutable data
Item 79: Avoid excessive synchronization
Item 80: Prefer executors, tasks, and streams to threads
Item 81: Prefer concurrency utilities to wait and notify
Item 82: Document thread safety
Item 83: Use lazy initialization judiciously
Item 84: Don’t depend on the thread scheduler
12 Serialization
Item 85: Prefer alternatives to Java serialization
Item 86: Implement Serializable with great caution
Item 87: Consider using a custom serialized form
Item 88: Write readObject methods defensively
Item 89: For instance control, prefer enum types to readResolve
Item 90: Consider serialization proxies instead of serialized instances
Items Corresponding to Second Edition
References
8
Index
9
Foreword
IF a colleague were to say to you, “Spouse of me this night today
manufactures the unusual meal in a home. You will join?” three things would
likely cross your mind: third, that you had been invited to dinner; second, that
English was not your colleague’s first language; and first, a good deal of
puzzlement.
If you have ever studied a second language yourself and then tried to use it
outside the classroom, you know that there are three things you must master:
how the language is structured (grammar), how to name things you want to
talk about (vocabulary), and the customary and effective ways to say
everyday things (usage). Too often only the first two are covered in the
classroom, and you find native speakers constantly suppressing their laughter
as you try to make yourself understood.
It is much the same with a programming language. You need to understand
the core language: is it algorithmic, functional, object-oriented? You need to
know the vocabulary: what data structures, operations, and facilities are
provided by the standard libraries? And you need to be familiar with the
customary and effective ways to structure your code. Books about
programming languages often cover only the first two, or discuss usage only
spottily. Maybe that’s because the first two are in some ways easier to write
about. Grammar and vocabulary are properties of the language alone, but
usage is characteristic of a community that uses it.
The Java programming language, for example, is object-oriented with
single inheritance and supports an imperative (statement-oriented) coding
style within each method. The libraries address graphic display support,
networking, distributed computing, and security. But how is the language best
put to use in practice?
There is another point. Programs, unlike spoken sentences and unlike most
books and magazines, are likely to be changed over time. It’s typically not
enough to produce code that operates effectively and is readily understood by
other persons; one must also organize the code so that it is easy to modify.
There may be ten ways to write code for some task T. Of those ten ways,
seven will be awkward, inefficient, or puzzling. Of the other three, which is
most likely to be similar to the code needed for the task T' in next year’s
software release?
There are numerous books from which you can learn the grammar of the
Java programming language, including The Java
™ Programming Language
by Arnold, Gosling, and Holmes, or The Java
™ Language Specification by
10
Gosling, Joy, yours truly, and Bracha. Likewise, there are dozens of books on
the libraries and APIs associated with the Java programming language.
This book addresses your third need: customary and effective usage. Joshua
Bloch has spent years extending, implementing, and using the Java
programming language at Sun Microsystems; he has also read a lot of other
people’s code, including mine. Here he offers good advice, systematically
organized, on how to structure your code so that it works well, so that other
people can understand it, so that future modifications and improvements are
less likely to cause headaches—perhaps, even, so that your programs will be
pleasant, elegant, and graceful.
Guy L. Steele Jr.
Burlington, Massachusetts
April 2001
11
Preface
Preface to the Third Edition
IN 1997, when Java was new, James Gosling (the father of Java), described it
as a “blue collar language” that was “pretty simple” [Gosling97]. At about the
same time, Bjarne Stroustrup (the father of C++) described C++ as a “multiparadigm language” that “deliberately differs from languages designed to
support a single way of writing programs” [Stroustrup95]. Stroustrup warned:
Much of the relative simplicity of Java is—like for most new languages—
partly an illusion and partly a function of its incompleteness. As time
passes, Java will grow significantly in size and complexity. It will double
or triple in size and grow implementation-dependent extensions or libraries.
[Stroustrup]
Now, twenty years later, it’s fair to say that Gosling and Stroustrup were both
right. Java is now large and complex, with multiple abstractions for many
things, from parallel execution, to iteration, to the representation of dates and
times.
I still like Java, though my ardor has cooled a bit as the platform has
grown. Given its increased size and complexity, the need for an up-to-date
best-practices guide is all the more critical. With this third edition of Effective
Java, I did my best to provide you with one. I hope this edition continues to
satisfy the need, while staying true to the spirit of the first two editions.
Small is beautiful, but simple ain’t easy.
San Jose, California
November 2017
P.S. I would be remiss if I failed to mention an industry-wide best practice
that has occupied a fair amount of my time lately. Since the birth of our field
in the 1950’s, we have freely reimplemented each others’ APIs. This practice
was critical to the meteoric success of computer technology. I am active in the
effort to preserve this freedom [CompSci17], and I encourage you to join me.
It is crucial to the continued health of our profession that we retain the right to
reimplement each others’ APIs.
Preface to the Second Edition
A lot has happened to the Java platform since I wrote the first edition of this
12
book in 2001, and it’s high time for a second edition. The most significant set
of changes was the addition of generics, enum types, annotations, autoboxing,
and the for-each loop in Java 5. A close second was the addition of the new
concurrency library, java.util.concurrent, also released in Java 5.
With Gilad Bracha, I had the good fortune to lead the teams that designed the
new language features. I also had the good fortune to serve on the team that
designed and developed the concurrency library, which was led by Doug Lea.
The other big change in the platform is the widespread adoption of modern
Integrated Development Environments (IDEs), such as Eclipse, IntelliJ IDEA,
and NetBeans, and of static analysis tools, such as FindBugs. While I have
not been involved in these efforts, I’ve benefited from them immensely and
learned how they affect the Java development experience.
In 2004, I moved from Sun to Google, but I’ve continued my involvement
in the development of the Java platform over the past four years, contributing
to the concurrency and collections APIs through the good offices of Google
and the Java Community Process. I’ve also had the pleasure of using the Java
platform to develop libraries for use within Google. Now I know what it feels
like to be a user.
As was the case in 2001 when I wrote the first edition, my primary goal is
to share my experience with you so that you can imitate my successes while
avoiding my failures. The new material continues to make liberal use of realworld examples from the Java platform libraries.
The first edition succeeded beyond my wildest expectations, and I’ve done
my best to stay true to its spirit while covering all of the new material that
was required to bring the book up to date. It was inevitable that the book
would grow, and grow it did, from fifty-seven items to seventy-eight. Not
only did I add twenty-three items, but I thoroughly revised all the original
material and retired a few items whose better days had passed. In the
Appendix, you can see how the material in this edition relates to the material
in the first edition.
In the Preface to the First Edition, I wrote that the Java programming
language and its libraries were immensely conducive to quality and
productivity, and a joy to work with. The changes in releases 5 and 6 have
taken a good thing and made it better. The platform is much bigger now than
it was in 2001 and more complex, but once you learn the patterns and idioms
for using the new features, they make your programs better and your life
easier. I hope this edition captures my continued enthusiasm for the platform
and helps make your use of the platform and its new features more effective
and enjoyable.
San Jose, California
April 2008
13
Preface to the First Edition
In 1996 I pulled up stakes and headed west to work for JavaSoft, as it was
then known, because it was clear that that was where the action was. In the
intervening five years I’ve served as Java platform libraries architect. I’ve
designed, implemented, and maintained many of the libraries and served as a
consultant for many others. Presiding over these libraries as the Java platform
matured was a once-in-a-lifetime opportunity. It is no exaggeration to say that
I had the privilege to work with some of the great software engineers of our
generation. In the process, I learned a lot about the Java programming
language—what works, what doesn’t, and how to use the language and its
libraries to best effect.
This book is my attempt to share my experience with you so that you can
imitate my successes while avoiding my failures. I borrowed the format from
Scott Meyers’s Effective C++, which consists of fifty items, each conveying
one specific rule for improving your programs and designs. I found the format
to be singularly effective, and I hope you do too.
In many cases, I took the liberty of illustrating the items with real-world
examples from the Java platform libraries. When describing something that
could have been done better, I tried to pick on code that I wrote myself, but
occasionally I pick on something written by a colleague. I sincerely apologize
if, despite my best efforts, I’ve offended anyone. Negative examples are cited
not to cast blame but in the spirit of cooperation, so that all of us can benefit
from the experience of those who’ve gone before.
While this book is not targeted solely at developers of reusable
components, it is inevitably colored by my experience writing such
components over the past two decades. I naturally think in terms of exported
APIs (Application Programming Interfaces), and I encourage you to do
likewise. Even if you aren’t developing reusable components, thinking in
these terms tends to improve the quality of the software you write.
Furthermore, it’s not uncommon to write a reusable component without
knowing it: You write something useful, share it with your buddy across the
hall, and before long you have half a dozen users. At this point, you no longer
have the flexibility to change the API at will and are thankful for all the effort
that you put into designing the API when you first wrote the software.
My focus on API design may seem a bit unnatural to devotees of the new
lightweight software development methodologies, such as Extreme
Programming. These methodologies emphasize writing the simplest program
that could possibly work. If you’re using one of these methodologies, you’ll
find that a focus on API design serves you well in the refactoring process.
The fundamental goals of refactoring are the improvement of system structure
and the avoidance of code duplication. These goals are impossible to achieve
14
in the absence of well-designed APIs for the components of the system.
No language is perfect, but some are excellent. I have found the Java
programming language and its libraries to be immensely conducive to quality
and productivity, and a joy to work with. I hope this book captures my
enthusiasm and helps make your use of the language more effective and
enjoyable.
Cupertino, California
April 2001
15
Acknowledgments
Acknowledgments for the Third Edition
I thank the readers of the first two editions of this book for giving it such a
kind and enthusiastic reception, for taking its ideas to heart, and for letting me
know what a positive influence it had on them and their work. I thank the
many professors who used the book in their courses, and the many
engineering teams that adopted it.
I thank the whole team at Addison-Wesley and Pearson for their kindness,
professionalism, patience, and grace under extreme pressure. Through it all,
my editor Greg Doench remained unflappable: a fine editor and a perfect
gentleman. I’m afraid his hair may have turned a bit gray as a result of this
project, and I humbly apologize. My project manager, Julie Nahil, and my
project editor, Dana Wilson, were all I could hope for: diligent, prompt,
organized, and friendly. My copy editor, Kim Wimpsett, was meticulous and
tasteful.
I have yet again been blessed with the best team of reviewers imaginable,
and I give my sincerest thanks to each of them. The core team, who reviewed
most every chapter, consisted of Cindy Bloch, Brian Kernighan, Kevin
Bourrillion, Joe Bowbeer, William Chargin, Joe Darcy, Brian Goetz, Tim
Halloran, Stuart Marks, Tim Peierls, and Yoshiki Shibata, Other reviewers
included Marcus Biel, Dan Bloch, Beth Bottos, Martin Buchholz, Michael
Diamond, Charlie Garrod, Tom Hawtin, Doug Lea, Aleksey Shipilëv, Lou
Wasserman, and Peter Weinberger. These reviewers made numerous
suggestions that led to great improvements in this book and saved me from
many embarrassments.
I give special thanks to William Chargin, Doug Lea, and Tim Peierls, who
served as sounding boards for many of the ideas in this book. William, Doug,
and Tim were unfailingly generous with their time and knowledge.
Finally, I thank my wife, Cindy Bloch, for encouraging me to write, for
reading each item in raw form, for writing the index, for helping me with all
of the things that invariably come up when you take on a big project, and for
putting up with me while I wrote.
Acknowledgments for the Second Edition
I thank the readers of the first edition of this book for giving it such a kind
and enthusiastic reception, for taking its ideas to heart, and for letting me
16
know what a positive influence it had on them and their work. I thank the
many professors who used the book in their courses, and the many
engineering teams that adopted it.
I thank the whole team at Addison-Wesley for their kindness,
professionalism, patience, and grace under pressure. Through it all, my editor
Greg Doench remained unflappable: a fine editor and a perfect gentleman.
My production manager, Julie Nahil, was everything that a production
manager should be: diligent, prompt, organized, and friendly. My copy editor,
Barbara Wood, was meticulous and tasteful.
I have once again been blessed with the best team of reviewers imaginable,
and I give my sincerest thanks to each of them. The core team, who reviewed
every chapter, consisted of Lexi Baugher, Cindy Bloch, Beth Bottos, Joe
Bowbeer, Brian Goetz, Tim Halloran, Brian Kernighan, Rob Konigsberg, Tim
Peierls, Bill Pugh, Yoshiki Shibata, Peter Stout, Peter Weinberger, and Frank
Yellin. Other reviewers included Pablo Bellver, Dan Bloch, Dan Bornstein,
Kevin Bourrillion, Martin Buchholz, Joe Darcy, Neal Gafter, Laurence
Gonsalves, Aaron Greenhouse, Barry Hayes, Peter Jones, Angelika Langer,
Doug Lea, Bob Lee, Jeremy Manson, Tom May, Mike McCloskey, Andriy
Tereshchenko, and Paul Tyma. Again, these reviewers made numerous
suggestions that led to great improvements in this book and saved me from
many embarrassments. And again, any remaining embarrassments are my
responsibility.
I give special thanks to Doug Lea and Tim Peierls, who served as sounding
boards for many of the ideas in this book. Doug and Tim were unfailingly
generous with their time and knowledge.
I thank my manager at Google, Prabha Krishna, for her continued support
and encouragement.
Finally, I thank my wife, Cindy Bloch, for encouraging me to write, for
reading each item in raw form, for helping me with Framemaker, for writing
the index, and for putting up with me while I wrote.
Acknowledgments for the First Edition
I thank Patrick Chan for suggesting that I write this book and for pitching the
idea to Lisa Friendly, the series managing editor; Tim Lindholm, the series
technical editor; and Mike Hendrickson, executive editor of Addison-Wesley.
I thank Lisa, Tim, and Mike for encouraging me to pursue the project and for
their superhuman patience and unyielding faith that I would someday write
this book.
I thank James Gosling and his original team for giving me something great
to write about, and I thank the many Java platform engineers who followed in
17
James’s footsteps. In particular, I thank my colleagues in Sun’s Java Platform
Tools and Libraries Group for their insights, their encouragement, and their
support. The team consists of Andrew Bennett, Joe Darcy, Neal Gafter, Iris
Garcia, Konstantin Kladko, Ian Little, Mike McCloskey, and Mark Reinhold.
Former members include Zhenghua Li, Bill Maddox, and Naveen Sanjeeva.
I thank my manager, Andrew Bennett, and my director, Larry Abrahams,
for lending their full and enthusiastic support to this project. I thank Rich
Green, the VP of Engineering at Java Software, for providing an environment
where engineers are free to think creatively and to publish their work.
I have been blessed with the best team of reviewers imaginable, and I give
my sincerest thanks to each of them: Andrew Bennett, Cindy Bloch, Dan
Bloch, Beth Bottos, Joe Bowbeer, Gilad Bracha, Mary Campione, Joe Darcy,
David Eckhardt, Joe Fialli, Lisa Friendly, James Gosling, Peter Haggar,
David Holmes, Brian Kernighan, Konstantin Kladko, Doug Lea, Zhenghua
Li, Tim Lindholm, Mike McCloskey, Tim Peierls, Mark Reinhold, Ken
Russell, Bill Shannon, Peter Stout, Phil Wadler, and two anonymous
reviewers. They made numerous suggestions that led to great improvements
in this book and saved me from many embarrassments. Any remaining
embarrassments are my responsibility.
Numerous colleagues, inside and outside Sun, participated in technical
discussions that improved the quality of this book. Among others, Ben
Gomes, Steffen Grarup, Peter Kessler, Richard Roda, John Rose, and David
Stoutamire contributed useful insights. A special thanks is due Doug Lea,
who served as a sounding board for many of the ideas in this book. Doug has
been unfailingly generous with his time and his knowledge.
I thank Julie Dinicola, Jacqui Doucette, Mike Hendrickson, Heather
Olszyk, Tracy Russ, and the whole team at Addison-Wesley for their support
and professionalism. Even under an impossibly tight schedule, they were
always friendly and accommodating.
I thank Guy Steele for writing the Foreword. I am honored that he chose to
participate in this project.
Finally, I thank my wife, Cindy Bloch, for encouraging and occasionally
threatening me to write this book, for reading each item in its raw form, for
helping me with Framemaker, for writing the index, and for putting up with
me while I wrote.
18
Chapter 1. Introduction
THIS book is designed to help you make effective use of the Java
programming language and its fundamental libraries: java.lang,
java.util, and java.io, and subpackages such as
java.util.concurrent and java.util.function. Other libraries
are discussed from time to time.
This book consists of ninety items, each of which conveys one rule. The
rules capture practices generally held to be beneficial by the best and most
experienced programmers. The items are loosely grouped into eleven
chapters, each covering one broad aspect of software design. The book is not
intended to be read from cover to cover: each item stands on its own, more or
less. The items are heavily cross-referenced so you can easily plot your own
course through the book.
Many new features were added to the platform since the last edition of this
book was published. Most of the items in this book use these features in some
way. This table shows you where to go for primary coverage of key features:
Feature Items Release
Lambdas Items 42–44 Java 8
Streams Items 45–48 Java 8
Optionals Item 55 Java 8
Default methods in interfaces Item 21 Java 8
try-with-resources Item 9 Java 7
@SafeVarargs Item 32 Java 7
Modules Item 15 Java 9
Most items are illustrated with program examples. A key feature of this
book is that it contains code examples illustrating many design patterns and
idioms. Where appropriate, they are cross-referenced to the standard reference
work in this area [Gamma95].
Many items contain one or more program examples illustrating some
practice to be avoided. Such examples, sometimes known as antipatterns, are
clearly labeled with a comment such as // Never do this!. In each
case, the item explains why the example is bad and suggests an alternative
19
approach.
This book is not for beginners: it assumes that you are already comfortable
with Java. If you are not, consider one of the many fine introductory texts,
such as Peter Sestoft’s Java Precisely [Sestoft16]. While Effective Java is
designed to be accessible to anyone with a working knowledge of the
language, it should provide food for thought even for advanced programmers.
Most of the rules in this book derive from a few fundamental principles.
Clarity and simplicity are of paramount importance. The user of a component
should never be surprised by its behavior. Components should be as small as
possible but no smaller. (As used in this book, the term component refers to
any reusable software element, from an individual method to a complex
framework consisting of multiple packages.) Code should be reused rather
than copied. The dependencies between components should be kept to a
minimum. Errors should be detected as soon as possible after they are made,
ideally at compile time.
While the rules in this book do not apply 100 percent of the time, they do
characterize best programming practices in the great majority of cases. You
should not slavishly follow these rules, but violate them only occasionally and
with good reason. Learning the art of programming, like most other
disciplines, consists of first learning the rules and then learning when to break
them.
For the most part, this book is not about performance. It is about writing
programs that are clear, correct, usable, robust, flexible, and maintainable. If
you can do that, it’s usually a relatively simple matter to get the performance
you need (Item 67). Some items do discuss performance concerns, and a few
of these items provide performance numbers. These numbers, which are
introduced with the phrase “On my machine,” should be regarded as
approximate at best.
For what it’s worth, my machine is an aging homebuilt 3.5GHz quad-core
Intel Core i7-4770K with 16 gigabytes of DDR3-1866 CL9 RAM, running
Azul’s Zulu 9.0.0.15 release of OpenJDK, atop Microsoft Windows 7
Professional SP1 (64-bit).
When discussing features of the Java programming language and its
libraries, it is sometimes necessary to refer to specific releases. For
convenience, this book uses nicknames in preference to official release
names. This table shows the mapping between release names and nicknames:
Official Release Name Nickname
JDK 1.0.x Java 1.0
JDK 1.1.x Java 1.1
20
Java 2 Platform, Standard Edition, v1.2 Java 2
Java 2 Platform, Standard Edition, v1.3 Java 3
Java 2 Platform, Standard Edition, v1.4 Java 4
Java 2 Platform, Standard Edition, v5.0 Java 5
Java Platform, Standard Edition 6 Java 6
Java Platform, Standard Edition 7 Java 7
Java Platform, Standard Edition 8 Java 8
Java Platform, Standard Edition 9 Java 9
The examples are reasonably complete, but favor readability over
completeness. They freely use classes from packages java.util and
java.io. In order to compile examples, you may have to add one or more
import declarations, or other such boilerplate. The book’s website,
http://joshbloch.com/effectivejava, contains an expanded
version of each example, which you can compile and run.
For the most part, this book uses technical terms as they are defined in The
Java Language Specification, Java SE 8 Edition [JLS]. A few terms deserve
special mention. The language supports four kinds of types: interfaces
(including annotations), classes (including enums), arrays, and primitives.
The first three are known as reference types. Class instances and arrays are
objects; primitive values are not. A class’s members consist of its fields,
methods, member classes, and member interfaces. A method’s signature
consists of its name and the types of its formal parameters; the signature does
not include the method’s return type.
This book uses a few terms differently from The Java Language
Specification. Unlike The Java Language Specification, this book uses
inheritance as a synonym for subclassing. Instead of using the term
inheritance for interfaces, this book simply states that a class implements an
interface or that one interface extends another. To describe the access level
that applies when none is specified, this book uses the traditional packageprivate instead of the technically correct package access [JLS, 6.6.1].
This book uses a few technical terms that are not defined in The Java
Language Specification. The term exported API, or simply API, refers to the
classes, interfaces, constructors, members, and serialized forms by which a
programmer accesses a class, interface, or package. (The term API, which is
short for application programming interface, is used in preference to the
otherwise preferable term interface to avoid confusion with the language
construct of that name.) A programmer who writes a program that uses an
21
API is referred to as a user of the API. A class whose implementation uses an
API is a client of the API.
Classes, interfaces, constructors, members, and serialized forms are
collectively known as API elements. An exported API consists of the API
elements that are accessible outside of the package that defines the API.
These are the API elements that any client can use and the author of the API
commits to support. Not coincidentally, they are also the elements for which
the Javadoc utility generates documentation in its default mode of operation.
Loosely speaking, the exported API of a package consists of the public and
protected members and constructors of every public class or interface in the
package.
In Java 9, a module system was added to the platform. If a library makes
use of the module system, its exported API is the union of the exported APIs
of all the packages exported by the library’s module declaration.
22
Chapter 2. Creating and Destroying
Objects
THIS chapter concerns creating and destroying objects: when and how to
create them, when and how to avoid creating them, how to ensure they are
destroyed in a timely manner, and how to manage any cleanup actions that
must precede their destruction.
Item 1: Consider static factory methods instead of
constructors
The traditional way for a class to allow a client to obtain an instance is to
provide a public constructor. There is another technique that should be a part
of every programmer’s toolkit. A class can provide a public static factory
method, which is simply a static method that returns an instance of the class.
Here’s a simple example from Boolean (the boxed primitive class for
boolean). This method translates a boolean primitive value into a
Boolean object reference:
Click here to view code image
public static Boolean valueOf(boolean b) {
return b ? Boolean.TRUE : Boolean.FALSE;
}
Note that a static factory method is not the same as the Factory Method
pattern from Design Patterns [Gamma95]. The static factory method
described in this item has no direct equivalent in Design Patterns.
A class can provide its clients with static factory methods instead of, or in
addition to, public constructors. Providing a static factory method instead of a
public constructor has both advantages and disadvantages.
One advantage of static factory methods is that, unlike constructors,
they have names. If the parameters to a constructor do not, in and of
themselves, describe the object being returned, a static factory with a wellchosen name is easier to use and the resulting client code easier to read. For
example, the constructor BigInteger(int, int, Random), which
returns a BigInteger that is probably prime, would have been better
expressed as a static factory method named
BigInteger.probablePrime. (This method was added in Java 4.)
A class can have only a single constructor with a given signature.
23
Programmers have been known to get around this restriction by providing two
constructors whose parameter lists differ only in the order of their parameter
types. This is a really bad idea. The user of such an API will never be able to
remember which constructor is which and will end up calling the wrong one
by mistake. People reading code that uses these constructors will not know
what the code does without referring to the class documentation.
Because they have names, static factory methods don’t share the restriction
discussed in the previous paragraph. In cases where a class seems to require
multiple constructors with the same signature, replace the constructors with
static factory methods and carefully chosen names to highlight their
differences.
A second advantage of static factory methods is that, unlike
constructors, they are not required to create a new object each time
they’re invoked. This allows immutable classes (Item 17) to use
preconstructed instances, or to cache instances as they’re constructed, and
dispense them repeatedly to avoid creating unnecessary duplicate objects. The
Boolean.valueOf(boolean) method illustrates this technique: it never
creates an object. This technique is similar to the Flyweight pattern
[Gamma95]. It can greatly improve performance if equivalent objects are
requested often, especially if they are expensive to create.
The ability of static factory methods to return the same object from
repeated invocations allows classes to maintain strict control over what
instances exist at any time. Classes that do this are said to be instancecontrolled. There are several reasons to write instance-controlled classes.
Instance control allows a class to guarantee that it is a singleton (Item 3) or
noninstantiable (Item 4). Also, it allows an immutable value class (Item 17) to
make the guarantee that no two equal instances exist: a.equals(b) if and
only if a == b. This is the basis of the Flyweight pattern [Gamma95]. Enum
types (Item 34) provide this guarantee.
A third advantage of static factory methods is that, unlike
constructors, they can return an object of any subtype of their return
type. This gives you great flexibility in choosing the class of the returned
object.
One application of this flexibility is that an API can return objects without
making their classes public. Hiding implementation classes in this fashion
leads to a very compact API. This technique lends itself to interface-based
frameworks (Item 20), where interfaces provide natural return types for static
factory methods.
Prior to Java 8, interfaces couldn’t have static methods. By convention,
static factory methods for an interface named Type were put in a
noninstantiable companion class (Item 4) named Types. For example, the
Java Collections Framework has forty-five utility implementations of its
24
interfaces, providing unmodifiable collections, synchronized collections, and
the like. Nearly all of these implementations are exported via static factory
methods in one noninstantiable class (java.util.Collections). The
classes of the returned objects are all nonpublic.
The Collections Framework API is much smaller than it would have been
had it exported forty-five separate public classes, one for each convenience
implementation. It is not just the bulk of the API that is reduced but the
conceptual weight: the number and difficulty of the concepts that
programmers must master in order to use the API. The programmer knows
that the returned object has precisely the API specified by its interface, so
there is no need to read additional class documentation for the implementation
class. Furthermore, using such a static factory method requires the client to
refer to the returned object by interface rather than implementation class,
which is generally good practice (Item 64).
As of Java 8, the restriction that interfaces cannot contain static methods
was eliminated, so there is typically little reason to provide a noninstantiable
companion class for an interface. Many public static members that would
have been at home in such a class should instead be put in the interface itself.
Note, however, that it may still be necessary to put the bulk of the
implementation code behind these static methods in a separate packageprivate class. This is because Java 8 requires all static members of an
interface to be public. Java 9 allows private static methods, but static fields
and static member classes are still required to be public.
A fourth advantage of static factories is that the class of the returned
object can vary from call to call as a function of the input parameters.
Any subtype of the declared return type is permissible. The class of the
returned object can also vary from release to release.
The EnumSet class (Item 36) has no public constructors, only static
factories. In the OpenJDK implementation, they return an instance of one of
two subclasses, depending on the size of the underlying enum type: if it has
sixty-four or fewer elements, as most enum types do, the static factories
return a RegularEnumSet instance, which is backed by a single long; if
the enum type has sixty-five or more elements, the factories return a
JumboEnumSet instance, backed by a long array.
The existence of these two implementation classes is invisible to clients. If
RegularEnumSet ceased to offer performance advantages for small enum
types, it could be eliminated from a future release with no ill effects.
Similarly, a future release could add a third or fourth implementation of
EnumSet if it proved beneficial for performance. Clients neither know nor
care about the class of the object they get back from the factory; they care
only that it is some subclass of EnumSet.
25
A fifth advantage of static factories is that the class of the returned
object need not exist when the class containing the method is written.
Such flexible static factory methods form the basis of service provider
frameworks, like the Java Database Connectivity API (JDBC). A service
provider framework is a system in which providers implement a service, and
the system makes the implementations available to clients, decoupling the
clients from the implementations.
There are three essential components in a service provider framework: a
service interface, which represents an implementation; a provider registration
API, which providers use to register implementations; and a service access
API, which clients use to obtain instances of the service. The service access
API may allow clients to specify criteria for choosing an implementation. In
the absence of such criteria, the API returns an instance of a default
implementation, or allows the client to cycle through all available
implementations. The service access API is the flexible static factory that
forms the basis of the service provider framework.
An optional fourth component of a service provider framework is a service
provider interface, which describes a factory object that produce instances of
the service interface. In the absence of a service provider interface,
implementations must be instantiated reflectively (Item 65). In the case of
JDBC, Connection plays the part of the service interface,
DriverManager.registerDriver is the provider registration API,
DriverManager.getConnection is the service access API, and
Driver is the service provider interface.
There are many variants of the service provider framework pattern. For
example, the service access API can return a richer service interface to clients
than the one furnished by providers. This is the Bridge pattern [Gamma95].
Dependency injection frameworks (Item 5) can be viewed as powerful service
providers. Since Java 6, the platform includes a general-purpose service
provider framework, java.util.ServiceLoader, so you needn’t, and
generally shouldn’t, write your own (Item 59). JDBC doesn’t use
ServiceLoader, as the former predates the latter.
The main limitation of providing only static factory methods is that
classes without public or protected constructors cannot be subclassed.
For example, it is impossible to subclass any of the convenience
implementation classes in the Collections Framework. Arguably this can be a
blessing in disguise because it encourages programmers to use composition
instead of inheritance (Item 18), and is required for immutable types (Item
17).
A second shortcoming of static factory methods is that they are hard
for programmers to find. They do not stand out in API documentation in the
26
way that constructors do, so it can be difficult to figure out how to instantiate
a class that provides static factory methods instead of constructors. The
Javadoc tool may someday draw attention to static factory methods. In the
meantime, you can reduce this problem by drawing attention to static
factories in class or interface documentation and by adhering to common
naming conventions. Here are some common names for static factory
methods. This list is far from exhaustive:
• from—A type-conversion method that takes a single parameter and
returns a corresponding instance of this type, for example:
Date d = Date.from(instant);
• of—An aggregation method that takes multiple parameters and returns an
instance of this type that incorporates them, for example:
Click here to view code image
Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
• valueOf—A more verbose alternative to from and of, for example:
Click here to view code image
BigInteger prime =
BigInteger.valueOf(Integer.MAX_VALUE);
• instance or getInstance—Returns an instance that is described by
its parameters (if any) but cannot be said to have the same value, for
example:
Click here to view code image
StackWalker luke = StackWalker.getInstance(options);
• create or newInstance—Like instance or getInstance,
except that the method guarantees that each call returns a new instance, for
example:
Click here to view code image
Object newArray = Array.newInstance(classObject,
arrayLen);
• getType—Like getInstance, but used if the factory method is in a
different class. Type is the type of object returned by the factory method,
for example:
Click here to view code image
FileStore fs = Files.getFileStore(path);
27
• newType—Like newInstance, but used if the factory method is in a
different class. Type is the type of object returned by the factory method,
for example:
Click here to view code image
BufferedReader br = Files.newBufferedReader(path);
• type—A concise alternative to getType and newType, for example:
Click here to view code image
List<Complaint> litany = Collections.list(legacyLitany);
In summary, static factory methods and public constructors both have their
uses, and it pays to understand their relative merits. Often static factories are
preferable, so avoid the reflex to provide public constructors without first
considering static factories.
Item 2: Consider a builder when faced with many
constructor parameters
Static factories and constructors share a limitation: they do not scale well to
large numbers of optional parameters. Consider the case of a class
representing the Nutrition Facts label that appears on packaged foods. These
labels have a few required fields—serving size, servings per container, and
calories per serving—and more than twenty optional fields—total fat,
saturated fat, trans fat, cholesterol, sodium, and so on. Most products have
nonzero values for only a few of these optional fields.
What sort of constructors or static factories should you write for such a
class? Traditionally, programmers have used the telescoping constructor
pattern, in which you provide a constructor with only the required parameters,
another with a single optional parameter, a third with two optional
parameters, and so on, culminating in a constructor with all the optional
parameters. Here’s how it looks in practice. For brevity’s sake, only four
optional fields are shown:
Click here to view code image
// Telescoping constructor pattern - does not scale
well!
public class NutritionFacts {
private final int servingSize; //
(mL) required
private final int servings; // (per container)
required
private final int calories; // (per
28
serving) optional
private final int fat; //
(g/serving) optional
private final int sodium; //
(mg/serving) optional
private final int carbohydrate; // (g/serving)
optional
public NutritionFacts(int servingSize, int servings)
{
this(servingSize, servings, 0);
}
public NutritionFacts(int servingSize, int servings,
int calories) {
this(servingSize, servings, calories, 0);
}
public NutritionFacts(int servingSize, int servings,
int calories, int fat) {
this(servingSize, servings, calories, fat, 0);
}
public NutritionFacts(int servingSize, int servings,
int calories, int fat, int sodium) {
this(servingSize, servings, calories, fat,
sodium, 0);
}
public NutritionFacts(int servingSize, int servings,
int calories, int fat, int sodium, int
carbohydrate) {
this.servingSize = servingSize;
this.servings = servings;
this.calories = calories;
this.fat = fat;
this.sodium = sodium;
this.carbohydrate = carbohydrate;
}
}
When you want to create an instance, you use the constructor with the
shortest parameter list containing all the parameters you want to set:
Click here to view code image
NutritionFacts cocaCola =
new NutritionFacts(240, 8, 100, 0, 35, 27);
29
Typically this constructor invocation will require many parameters that you
don’t want to set, but you’re forced to pass a value for them anyway. In this
case, we passed a value of 0 for fat. With “only” six parameters this may
not seem so bad, but it quickly gets out of hand as the number of parameters
increases.
In short, the telescoping constructor pattern works, but it is hard to
write client code when there are many parameters, and harder still to
read it. The reader is left wondering what all those values mean and must
carefully count parameters to find out. Long sequences of identically typed
parameters can cause subtle bugs. If the client accidentally reverses two such
parameters, the compiler won’t complain, but the program will misbehave at
runtime (Item 51).
A second alternative when you’re faced with many optional parameters in a
constructor is the JavaBeans pattern, in which you call a parameterless
constructor to create the object and then call setter methods to set each
required parameter and each optional parameter of interest:
Click here to view code image
// JavaBeans Pattern - allows inconsistency, mandates
mutability
public class NutritionFacts {
// Parameters initialized to default values (if any)
private int servingSize = -1; // Required; no
default value
private int servings = -1; // Required; no
default value
private int calories = 0;
private int fat = 0;
private int sodium = 0;
private int carbohydrate = 0;
public NutritionFacts() { }
// Setters
public void setServingSize(int val) { servingSize =
val; }
public void setServings(int val) { servings =
val; }
public void setCalories(int val) { calories =
val; }
public void setFat(int val) { fat = val; }
public void setSodium(int val) { sodium = val;
}
public void setCarbohydrate(int val) { carbohydrate
= val; }
}
30
This pattern has none of the disadvantages of the telescoping constructor
pattern. It is easy, if a bit wordy, to create instances, and easy to read the
resulting code:
Click here to view code image
NutritionFacts cocaCola = new NutritionFacts();
cocaCola.setServingSize(240);
cocaCola.setServings(8);
cocaCola.setCalories(100);
cocaCola.setSodium(35);
cocaCola.setCarbohydrate(27);
Unfortunately, the JavaBeans pattern has serious disadvantages of its own.
Because construction is split across multiple calls, a JavaBean may be in an
inconsistent state partway through its construction. The class does not
have the option of enforcing consistency merely by checking the validity of
the constructor parameters. Attempting to use an object when it’s in an
inconsistent state may cause failures that are far removed from the code
containing the bug and hence difficult to debug. A related disadvantage is that
the JavaBeans pattern precludes the possibility of making a class
immutable (Item 17) and requires added effort on the part of the programmer
to ensure thread safety.
It is possible to reduce these disadvantages by manually “freezing” the
object when its construction is complete and not allowing it to be used until
frozen, but this variant is unwieldy and rarely used in practice. Moreover, it
can cause errors at runtime because the compiler cannot ensure that the
programmer calls the freeze method on an object before using it.
Luckily, there is a third alternative that combines the safety of the
telescoping constructor pattern with the readability of the JavaBeans pattern.
It is a form of the Builder pattern [Gamma95]. Instead of making the desired
object directly, the client calls a constructor (or static factory) with all of the
required parameters and gets a builder object. Then the client calls setter-like
methods on the builder object to set each optional parameter of interest.
Finally, the client calls a parameterless build method to generate the object,
which is typically immutable. The builder is typically a static member class
(Item 24) of the class it builds. Here’s how it looks in practice:
Click here to view code image
// Builder Pattern
public class NutritionFacts {
private final int servingSize;
private final int servings;
private final int calories;
private final int fat;
31
private final int sodium;
private final int carbohydrate;
public static class Builder {
// Required parameters
private final int servingSize;
private final int servings;
// Optional parameters - initialized to default
values
private int calories = 0;
private int fat = 0;
private int sodium = 0;
private int carbohydrate = 0;
public Builder(int servingSize, int servings) {
this.servingSize = servingSize;
this.servings = servings;
}
public Builder calories(int val)
{ calories = val; return this; }
public Builder fat(int val)
{ fat = val; return this; }
public Builder sodium(int val)
{ sodium = val; return this; }
public Builder carbohydrate(int val)
{ carbohydrate = val; return this; }
public NutritionFacts build() {
return new NutritionFacts(this);
}
}
private NutritionFacts(Builder builder) {
servingSize = builder.servingSize;
servings = builder.servings;
calories = builder.calories;
fat = builder.fat;
sodium = builder.sodium;
carbohydrate = builder.carbohydrate;
}
}
The NutritionFacts class is immutable, and all parameter default
values are in one place. The builder’s setter methods return the builder itself
so that invocations can be chained, resulting in a fluent API. Here’s how the
client code looks:
32
Click here to view code image
NutritionFacts cocaCola = new
NutritionFacts.Builder(240, 8)
.calories(100).sodium(35).carbohydrate(27).build();
This client code is easy to write and, more importantly, easy to read. The
Builder pattern simulates named optional parameters as found in Python
and Scala.
Validity checks were omitted for brevity. To detect invalid parameters as
soon as possible, check parameter validity in the builder’s constructor and
methods. Check invariants involving multiple parameters in the constructor
invoked by the build method. To ensure these invariants against attack, do
the checks on object fields after copying parameters from the builder (Item
50). If a check fails, throw an IllegalArgumentException (Item 72)
whose detail message indicates which parameters are invalid (Item 75).
The Builder pattern is well suited to class hierarchies. Use a parallel
hierarchy of builders, each nested in the corresponding class. Abstract classes
have abstract builders; concrete classes have concrete builders. For example,
consider an abstract class at the root of a hierarchy representing various kinds
of pizza:
Click here to view code image
// Builder pattern for class hierarchies
public abstract class Pizza {
public enum Topping { HAM, MUSHROOM, ONION, PEPPER,
SAUSAGE }
final Set<Topping> toppings;
abstract static class Builder<T extends Builder<T>> {
EnumSet<Topping> toppings =
EnumSet.noneOf(Topping.class);
public T addTopping(Topping topping) {
toppings.add(Objects.requireNonNull(topping));
return self();
}
abstract Pizza build();
// Subclasses must override this method to return
"this"
protected abstract T self();
}
Pizza(Builder<?> builder) {
toppings = builder.toppings.clone(); // See
Item 50
33
}
}
Note that Pizza.Builder is a generic type with a recursive type
parameter (Item 30). This, along with the abstract self method, allows
method chaining to work properly in subclasses, without the need for casts.
This workaround for the fact that Java lacks a self type is known as the
simulated self-type idiom.
Here are two concrete subclasses of Pizza, one of which represents a
standard New-York-style pizza, the other a calzone. The former has a
required size parameter, while the latter lets you specify whether sauce should
be inside or out:
Click here to view code image
public class NyPizza extends Pizza {
public enum Size { SMALL, MEDIUM, LARGE }
private final Size size;
public static class Builder extends
Pizza.Builder<Builder> {
private final Size size;
public Builder(Size size) {
this.size = Objects.requireNonNull(size);
}
@Override public NyPizza build() {
return new NyPizza(this);
}
@Override protected Builder self() { return
this; }
}
private NyPizza(Builder builder) {
super(builder);
size = builder.size;
}
}
public class Calzone extends Pizza {
private final boolean sauceInside;
public static class Builder extends
Pizza.Builder<Builder> {
private boolean sauceInside = false; // Default
34
public Builder sauceInside() {
sauceInside = true;
return this;
}
@Override public Calzone build() {
return new Calzone(this);
}
@Override protected Builder self() { return
this; }
}
private Calzone(Builder builder) {
super(builder);
sauceInside = builder.sauceInside;
}
}
Note that the build method in each subclass’s builder is declared to
return the correct subclass: the build method of NyPizza.Builder
returns NyPizza, while the one in Calzone.Builder returns Calzone.
This technique, wherein a subclass method is declared to return a subtype of
the return type declared in the super-class, is known as covariant return
typing. It allows clients to use these builders without the need for casting.
The client code for these “hierarchical builders” is essentially identical to
the code for the simple NutritionFacts builder. The example client code
shown next assumes static imports on enum constants for brevity:
Click here to view code image
NyPizza pizza = new NyPizza.Builder(SMALL)
.addTopping(SAUSAGE).addTopping(ONION).build();
Calzone calzone = new Calzone.Builder()
.addTopping(HAM).sauceInside().build();
A minor advantage of builders over constructors is that builders can have
multiple varargs parameters because each parameter is specified in its own
method. Alternatively, builders can aggregate the parameters passed into
multiple calls to a method into a single field, as demonstrated in the
addTopping method earlier.
The Builder pattern is quite flexible. A single builder can be used
repeatedly to build multiple objects. The parameters of the builder can be
tweaked between invocations of the build method to vary the objects that
are created. A builder can fill in some fields automatically upon object
creation, such as a serial number that increases each time an object is created.
35
The Builder pattern has disadvantages as well. In order to create an object,
you must first create its builder. While the cost of creating this builder is
unlikely to be noticeable in practice, it could be a problem in performancecritical situations. Also, the Builder pattern is more verbose than the
telescoping constructor pattern, so it should be used only if there are enough
parameters to make it worthwhile, say four or more. But keep in mind that
you may want to add more parameters in the future. But if you start out with
constructors or static factories and switch to a builder when the class evolves
to the point where the number of parameters gets out of hand, the obsolete
constructors or static factories will stick out like a sore thumb. Therefore, it’s
often better to start with a builder in the first place.
In summary, the Builder pattern is a good choice when designing classes
whose constructors or static factories would have more than a handful of
parameters, especially if many of the parameters are optional or of identical
type. Client code is much easier to read and write with builders than with
telescoping constructors, and builders are much safer than JavaBeans.
Item 3: Enforce the singleton property with a private
constructor or an enum type
A singleton is simply a class that is instantiated exactly once [Gamma95].
Singletons typically represent either a stateless object such as a function (Item
24) or a system component that is intrinsically unique. Making a class a
singleton can make it difficult to test its clients because it’s impossible to
substitute a mock implementation for a singleton unless it implements an
interface that serves as its type.
There are two common ways to implement singletons. Both are based on
keeping the constructor private and exporting a public static member to
provide access to the sole instance. In one approach, the member is a final
field:
Click here to view code image
// Singleton with public final field
public class Elvis {
public static final Elvis INSTANCE = new Elvis();
private Elvis() { ... }
public void leaveTheBuilding() { ... }
}
The private constructor is called only once, to initialize the public static
final field Elvis.INSTANCE. The lack of a public or protected constructor
guarantees a “monoelvistic” universe: exactly one Elvis instance will exist
36
once the Elvis class is initialized—no more, no less. Nothing that a client
does can change this, with one caveat: a privileged client can invoke the
private constructor reflectively (Item 65) with the aid of the
AccessibleObject.setAccessible method. If you need to defend
against this attack, modify the constructor to make it throw an exception if it’s
asked to create a second instance.
In the second approach to implementing singletons, the public member is a
static factory method:
Click here to view code image
// Singleton with static factory
public class Elvis {
private static final Elvis INSTANCE = new Elvis();
private Elvis() { ... }
public static Elvis getInstance() { return INSTANCE;
}
public void leaveTheBuilding() { ... }
}
All calls to Elvis.getInstance return the same object reference, and no
other Elvis instance will ever be created (with the same caveat mentioned
earlier).
The main advantage of the public field approach is that the API makes it
clear that the class is a singleton: the public static field is final, so it will
always contain the same object reference. The second advantage is that it’s
simpler.
One advantage of the static factory approach is that it gives you the
flexibility to change your mind about whether the class is a singleton without
changing its API. The factory method returns the sole instance, but it could be
modified to return, say, a separate instance for each thread that invokes it. A
second advantage is that you can write a generic singleton factory if your
application requires it (Item 30). A final advantage of using a static factory is
that a method reference can be used as a supplier, for example
Elvis::instance is a Supplier<Elvis>. Unless one of these
advantages is relevant, the public field approach is preferable.
To make a singleton class that uses either of these approaches serializable
(Chapter 12), it is not sufficient merely to add implements
Serializable to its declaration. To maintain the singleton guarantee,
declare all instance fields transient and provide a readResolve
method (Item 89). Otherwise, each time a serialized instance is deserialized, a
new instance will be created, leading, in the case of our example, to spurious
Elvis sightings. To prevent this from happening, add this readResolve
37
method to the Elvis class:
Click here to view code image
// readResolve method to preserve singleton property
private Object readResolve() {
// Return the one true Elvis and let the garbage
collector
// take care of the Elvis impersonator.
return INSTANCE;
}
A third way to implement a singleton is to declare a single-element enum:
Click here to view code image
// Enum singleton - the preferred approach
public enum Elvis {
INSTANCE;
public void leaveTheBuilding() { ... }
}
This approach is similar to the public field approach, but it is more concise,
provides the serialization machinery for free, and provides an ironclad
guarantee against multiple instantiation, even in the face of sophisticated
serialization or reflection attacks. This approach may feel a bit unnatural, but
a single-element enum type is often the best way to implement a
singleton. Note that you can’t use this approach if your singleton must extend
a superclass other than Enum (though you can declare an enum to implement
interfaces).
Item 4: Enforce noninstantiability with a private
constructor
Occasionally you’ll want to write a class that is just a grouping of static
methods and static fields. Such classes have acquired a bad reputation
because some people abuse them to avoid thinking in terms of objects, but
they do have valid uses. They can be used to group related methods on
primitive values or arrays, in the manner of java.lang.Math or
java.util.Arrays. They can also be used to group static methods,
including factories (Item 1), for objects that implement some interface, in the
manner of java.util.Collections. (As of Java 8, you can also put
such methods in the interface, assuming it’s yours to modify.) Lastly, such
classes can be used to group methods on a final class, since you can’t put
them in a subclass.
38
Such utility classes were not designed to be instantiated: an instance would
be nonsensical. In the absence of explicit constructors, however, the compiler
provides a public, parameterless default constructor. To a user, this
constructor is indistinguishable from any other. It is not uncommon to see
unintentionally instantiable classes in published APIs.
Attempting to enforce noninstantiability by making a class abstract
does not work. The class can be subclassed and the subclass instantiated.
Furthermore, it misleads the user into thinking the class was designed for
inheritance (Item 19). There is, however, a simple idiom to ensure
noninstantiability. A default constructor is generated only if a class contains
no explicit constructors, so a class can be made noninstantiable by
including a private constructor:
Click here to view code image
// Noninstantiable utility class
public class UtilityClass {
// Suppress default constructor for
noninstantiability
private UtilityClass() {
throw new AssertionError();
}
... // Remainder omitted
}
Because the explicit constructor is private, it is inaccessible outside the
class. The AssertionError isn’t strictly required, but it provides
insurance in case the constructor is accidentally invoked from within the
class. It guarantees the class will never be instantiated under any
circumstances. This idiom is mildly counterintuitive because the constructor
is provided expressly so that it cannot be invoked. It is therefore wise to
include a comment, as shown earlier.
As a side effect, this idiom also prevents the class from being subclassed.
All constructors must invoke a superclass constructor, explicitly or implicitly,
and a subclass would have no accessible superclass constructor to invoke.
Item 5: Prefer dependency injection to hardwiring
resources
Many classes depend on one or more underlying resources. For example, a
spell checker depends on a dictionary. It is not uncommon to see such classes
implemented as static utility classes (Item 4):
Click here to view code image
39
// Inappropriate use of static utility - inflexible &
untestable!
public class SpellChecker {
private static final Lexicon dictionary = ...;
private SpellChecker() {} // Noninstantiable
public static boolean isValid(String word) { ... }
public static List<String> suggestions(String typo)
{ ... }
}
Similarly, it’s not uncommon to see them implemented as singletons (Item 3):
Click here to view code image
// Inappropriate use of singleton - inflexible &
untestable!
public class SpellChecker {
private final Lexicon dictionary = ...;
private SpellChecker(...) {}
public static INSTANCE = new SpellChecker(...);
public boolean isValid(String word) { ... }
public List<String> suggestions(String typo) { ... }
}
Neither of these approaches is satisfactory, because they assume that there
is only one dictionary worth using. In practice, each language has its own
dictionary, and special dictionaries are used for special vocabularies. Also, it
may be desirable to use a special dictionary for testing. It is wishful thinking
to assume that a single dictionary will suffice for all time.
You could try to have SpellChecker support multiple dictionaries by
making the dictionary field nonfinal and adding a method to change the
dictionary in an existing spell checker, but this would be awkward, errorprone, and unworkable in a concurrent setting. Static utility classes and
singletons are inappropriate for classes whose behavior is parameterized
by an underlying resource.
What is required is the ability to support multiple instances of the class (in
our example, SpellChecker), each of which uses the resource desired by
the client (in our example, the dictionary). A simple pattern that satisfies this
requirement is to pass the resource into the constructor when creating a
new instance. This is one form of dependency injection: the dictionary is a
dependency of the spell checker and is injected into the spell checker when it
is created.
40
Click here to view code image
// Dependency injection provides flexibility and
testability
public class SpellChecker {
private final Lexicon dictionary;
public SpellChecker(Lexicon dictionary) {
this.dictionary =
Objects.requireNonNull(dictionary);
}
public boolean isValid(String word) { ... }
public List<String> suggestions(String typo) { ... }
}
The dependency injection pattern is so simple that many programmers use
it for years without knowing it has a name. While our spell checker example
had only a single resource (the dictionary), dependency injection works with
an arbitrary number of resources and arbitrary dependency graphs. It
preserves immutability (Item 17), so multiple clients can share dependent
objects (assuming the clients desire the same underlying resources).
Dependency injection is equally applicable to constructors, static factories
(Item 1), and builders (Item 2).
A useful variant of the pattern is to pass a resource factory to the
constructor. A factory is an object that can be called repeatedly to create
instances of a type. Such factories embody the Factory Method pattern
[Gamma95]. The Supplier<T> interface, introduced in Java 8, is perfect
for representing factories. Methods that take a Supplier<T> on input
should typically constrain the factory’s type parameter using a bounded
wildcard type (Item 31) to allow the client to pass in a factory that creates any
subtype of a specified type. For example, here is a method that makes a
mosaic using a client-provided factory to produce each tile:
Click here to view code image
Mosaic create(Supplier<? extends Tile> tileFactory) {
... }
Although dependency injection greatly improves flexibility and testability,
it can clutter up large projects, which typically contain thousands of
dependencies. This clutter can be all but eliminated by using a dependency
injection framework, such as Dagger [Dagger], Guice [Guice], or Spring
[Spring]. The use of these frameworks is beyond the scope of this book, but
note that APIs designed for manual dependency injection are trivially adapted
for use by these frameworks.
41
In summary, do not use a singleton or static utility class to implement a
class that depends on one or more underlying resources whose behavior
affects that of the class, and do not have the class create these resources
directly. Instead, pass the resources, or factories to create them, into the
constructor (or static factory or builder). This practice, known as dependency
injection, will greatly enhance the flexibility, reusability, and testability of a
class.
Item 6: Avoid creating unnecessary objects
It is often appropriate to reuse a single object instead of creating a new
functionally equivalent object each time it is needed. Reuse can be both faster
and more stylish. An object can always be reused if it is immutable (Item 17).
As an extreme example of what not to do, consider this statement:
Click here to view code image
String s = new String("bikini"); // DON'T DO THIS!
The statement creates a new String instance each time it is executed, and
none of those object creations is necessary. The argument to the String
constructor ("bikini") is itself a String instance, functionally identical
to all of the objects created by the constructor. If this usage occurs in a loop or
in a frequently invoked method, millions of String instances can be created
needlessly.
The improved version is simply the following:
String s = "bikini";
This version uses a single String instance, rather than creating a new one
each time it is executed. Furthermore, it is guaranteed that the object will be
reused by any other code running in the same virtual machine that happens to
contain the same string literal [JLS, 3.10.5].
You can often avoid creating unnecessary objects by using static factory
methods (Item 1) in preference to constructors on immutable classes that
provide both. For example, the factory method
Boolean.valueOf(String) is preferable to the constructor
Boolean(String), which was deprecated in Java 9. The constructor must
create a new object each time it’s called, while the factory method is never
required to do so and won’t in practice. In addition to reusing immutable
objects, you can also reuse mutable objects if you know they won’t be
modified.
Some object creations are much more expensive than others. If you’re
going to need such an “expensive object” repeatedly, it may be advisable to
42
cache it for reuse. Unfortunately, it’s not always obvious when you’re
creating such an object. Suppose you want to write a method to determine
whether a string is a valid Roman numeral. Here’s the easiest way to do this
using a regular expression:
Click here to view code image
// Performance can be greatly improved!
static boolean isRomanNumeral(String s) {
return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
+ "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
The problem with this implementation is that it relies on the
String.matches method. While String.matches is the easiest way
to check if a string matches a regular expression, it’s not suitable for
repeated use in performance-critical situations. The problem is that it
internally creates a Pattern instance for the regular expression and uses it
only once, after which it becomes eligible for garbage collection. Creating a
Pattern instance is expensive because it requires compiling the regular
expression into a finite state machine.
To improve the performance, explicitly compile the regular expression into
a Pattern instance (which is immutable) as part of class initialization,
cache it, and reuse the same instance for every invocation of the
isRomanNumeral method:
Click here to view code image
// Reusing expensive object for improved performance
public class RomanNumerals {
private static final Pattern ROMAN =
Pattern.compile(
"^(?=.)M*(C[MD]|D?C{0,3})"
+ "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
static boolean isRomanNumeral(String s) {
return ROMAN.matcher(s).matches();
}
}
The improved version of isRomanNumeral provides significant
performance gains if invoked frequently. On my machine, the original version
takes 1.1 µs on an 8-character input string, while the improved version takes
0.17 µs, which is 6.5 times faster. Not only is the performance improved, but
arguably, so is clarity. Making a static final field for the otherwise invisible
Pattern instance allows us to give it a name, which is far more readable
than the regular expression itself.
43
If the class containing the improved version of the isRomanNumeral
method is initialized but the method is never invoked, the field ROMAN will be
initialized needlessly. It would be possible to eliminate the initialization by
lazily initializing the field (Item 83) the first time the isRomanNumeral
method is invoked, but this is not recommended. As is often the case with
lazy initialization, it would complicate the implementation with no
measurable performance improvement (Item 67).
When an object is immutable, it is obvious it can be reused safely, but there
are other situations where it is far less obvious, even counterintuitive.
Consider the case of adapters [Gamma95], also known as views. An adapter
is an object that delegates to a backing object, providing an alternative
interface. Because an adapter has no state beyond that of its backing object,
there’s no need to create more than one instance of a given adapter to a given
object.
For example, the keySet method of the Map interface returns a Set view
of the Map object, consisting of all the keys in the map. Naively, it would
seem that every call to keySet would have to create a new Set instance,
but every call to keySet on a given Map object may return the same Set
instance. Although the returned Set instance is typically mutable, all of the
returned objects are functionally identical: when one of the returned objects
changes, so do all the others, because they’re all backed by the same Map
instance. While it is largely harmless to create multiple instances of the
keySet view object, it is unnecessary and has no benefits.
Another way to create unnecessary objects is autoboxing, which allows the
programmer to mix primitive and boxed primitive types, boxing and unboxing
automatically as needed. Autoboxing blurs but does not erase the
distinction between primitive and boxed primitive types. There are subtle
semantic distinctions and not-so-subtle performance differences (Item 61).
Consider the following method, which calculates the sum of all the positive
int values. To do this, the program has to use long arithmetic because an
int is not big enough to hold the sum of all the positive int values:
Click here to view code image
// Hideously slow! Can you spot the object creation?
private static long sum() {
Long sum = 0L;
for (long i = 0; i <= Integer.MAX_VALUE; i++)
sum += i;
return sum;
}
This program gets the right answer, but it is much slower than it should be,
44
due to a one-character typographical error. The variable sum is declared as a
Long instead of a long, which means that the program constructs about 2
31
unnecessary Long instances (roughly one for each time the long i is added
to the Long sum). Changing the declaration of sum from Long to long
reduces the runtime from 6.3 seconds to 0.59 seconds on my machine. The
lesson is clear: prefer primitives to boxed primitives, and watch out for
unintentional autoboxing.
This item should not be misconstrued to imply that object creation is
expensive and should be avoided. On the contrary, the creation and
reclamation of small objects whose constructors do little explicit work is
cheap, especially on modern JVM implementations. Creating additional
objects to enhance the clarity, simplicity, or power of a program is generally a
good thing.
Conversely, avoiding object creation by maintaining your own object pool
is a bad idea unless the objects in the pool are extremely heavyweight. The
classic example of an object that does justify an object pool is a database
connection. The cost of establishing the connection is sufficiently high that it
makes sense to reuse these objects. Generally speaking, however, maintaining
your own object pools clutters your code, increases memory footprint, and
harms performance. Modern JVM implementations have highly optimized
garbage collectors that easily outperform such object pools on lightweight
objects.
The counterpoint to this item is Item 50 on defensive copying. The present
item says, “Don’t create a new object when you should reuse an existing
one,” while Item 50 says, “Don’t reuse an existing object when you should
create a new one.” Note that the penalty for reusing an object when defensive
copying is called for is far greater than the penalty for needlessly creating a
duplicate object. Failing to make defensive copies where required can lead to
insidious bugs and security holes; creating objects unnecessarily merely
affects style and performance.
Item 7: Eliminate obsolete object references
If you switched from a language with manual memory management, such as
C or C++, to a garbage-collected language such as Java, your job as a
programmer was made much easier by the fact that your objects are
automatically reclaimed when you’re through with them. It seems almost like
magic when you first experience it. It can easily lead to the impression that
you don’t have to think about memory management, but this isn’t quite true.
Consider the following simple stack implementation:
Click here to view code image
45
// Can you spot the "memory leak"?
public class Stack {
private Object[] elements;
private int size = 0;
private static final int DEFAULT_INITIAL_CAPACITY =
16;
public Stack() {
elements = new Object[DEFAULT_INITIAL_CAPACITY];
}
public void push(Object e) {
ensureCapacity();
elements[size++] = e;
}
public Object pop() {
if (size == 0)
throw new EmptyStackException();
return elements[--size];
}
/**
* Ensure space for at least one more element,
roughly
* doubling the capacity each time the array needs
to grow.
*/
private void ensureCapacity() {
if (elements.length == size)
elements = Arrays.copyOf(elements, 2 * size
+ 1);
}
}
There’s nothing obviously wrong with this program (but see Item 29 for a
generic version). You could test it exhaustively, and it would pass every test
with flying colors, but there’s a problem lurking. Loosely speaking, the
program has a “memory leak,” which can silently manifest itself as reduced
performance due to increased garbage collector activity or increased memory
footprint. In extreme cases, such memory leaks can cause disk paging and
even program failure with an OutOfMemoryError, but such failures are
relatively rare.
So where is the memory leak? If a stack grows and then shrinks, the objects
that were popped off the stack will not be garbage collected, even if the
program using the stack has no more references to them. This is because the
stack maintains obsolete references to these objects. An obsolete reference is
46
simply a reference that will never be dereferenced again. In this case, any
references outside of the “active portion” of the element array are obsolete.
The active portion consists of the elements whose index is less than size.
Memory leaks in garbage-collected languages (more properly known as
unintentional object retentions) are insidious. If an object reference is
unintentionally retained, not only is that object excluded from garbage
collection, but so too are any objects referenced by that object, and so on.
Even if only a few object references are unintentionally retained, many, many
objects may be prevented from being garbage collected, with potentially large
effects on performance.
The fix for this sort of problem is simple: null out references once they
become obsolete. In the case of our Stack class, the reference to an item
becomes obsolete as soon as it’s popped off the stack. The corrected version
of the pop method looks like this:
Click here to view code image
public Object pop() {
if (size == 0)
throw new EmptyStackException();
Object result = elements[--size];
elements[size] = null; // Eliminate obsolete
reference
return result;
}
An added benefit of nulling out obsolete references is that if they are
subsequently dereferenced by mistake, the program will immediately fail with
a NullPointerException, rather than quietly doing the wrong thing. It
is always beneficial to detect programming errors as quickly as possible.
When programmers are first stung by this problem, they may
overcompensate by nulling out every object reference as soon as the program
is finished using it. This is neither necessary nor desirable; it clutters up the
program unnecessarily. Nulling out object references should be the
exception rather than the norm. The best way to eliminate an obsolete
reference is to let the variable that contained the reference fall out of scope.
This occurs naturally if you define each variable in the narrowest possible
scope (Item 57).
So when should you null out a reference? What aspect of the Stack class
makes it susceptible to memory leaks? Simply put, it manages its own
memory. The storage pool consists of the elements of the elements array
(the object reference cells, not the objects themselves). The elements in the
active portion of the array (as defined earlier) are allocated, and those in the
remainder of the array are free. The garbage collector has no way of knowing
47
this; to the garbage collector, all of the object references in the elements
array are equally valid. Only the programmer knows that the inactive portion
of the array is unimportant. The programmer effectively communicates this
fact to the garbage collector by manually nulling out array elements as soon
as they become part of the inactive portion.
Generally speaking, whenever a class manages its own memory, the
programmer should be alert for memory leaks. Whenever an element is
freed, any object references contained in the element should be nulled out.
Another common source of memory leaks is caches. Once you put an
object reference into a cache, it’s easy to forget that it’s there and leave it in
the cache long after it becomes irrelevant. There are several solutions to this
problem. If you’re lucky enough to implement a cache for which an entry is
relevant exactly so long as there are references to its key outside of the cache,
represent the cache as a WeakHashMap; entries will be removed
automatically after they become obsolete. Remember that WeakHashMap is
useful only if the desired lifetime of cache entries is determined by external
references to the key, not the value.
More commonly, the useful lifetime of a cache entry is less well defined,
with entries becoming less valuable over time. Under these circumstances, the
cache should occasionally be cleansed of entries that have fallen into disuse.
This can be done by a background thread (perhaps a
ScheduledThreadPoolExecutor) or as a side effect of adding new
entries to the cache. The LinkedHashMap class facilitates the latter
approach with its removeEldestEntry method. For more sophisticated
caches, you may need to use java.lang.ref directly.
A third common source of memory leaks is listeners and other
callbacks. If you implement an API where clients register callbacks but don’t
deregister them explicitly, they will accumulate unless you take some action.
One way to ensure that callbacks are garbage collected promptly is to store
only weak references to them, for instance, by storing them only as keys in a
WeakHashMap.
Because memory leaks typically do not manifest themselves as obvious
failures, they may remain present in a system for years. They are typically
discovered only as a result of careful code inspection or with the aid of a
debugging tool known as a heap profiler. Therefore, it is very desirable to
learn to anticipate problems like this before they occur and prevent them from
happening.
Item 8: Avoid finalizers and cleaners
Finalizers are unpredictable, often dangerous, and generally
48
unnecessary. Their use can cause erratic behavior, poor performance, and
portability problems. Finalizers have a few valid uses, which we’ll cover later
in this item, but as a rule, you should avoid them. As of Java 9, finalizers have
been deprecated, but they are still being used by the Java libraries. The Java 9
replacement for finalizers is cleaners. Cleaners are less dangerous than
finalizers, but still unpredictable, slow, and generally unnecessary.
C++ programmers are cautioned not to think of finalizers or cleaners as
Java’s analogue of C++ destructors. In C++, destructors are the normal way to
reclaim the resources associated with an object, a necessary counterpart to
constructors. In Java, the garbage collector reclaims the storage associated
with an object when it becomes unreachable, requiring no special effort on the
part of the programmer. C++ destructors are also used to reclaim other
nonmemory resources. In Java, a try-with-resources or try-finally
block is used for this purpose (Item 9).
One shortcoming of finalizers and cleaners is that there is no guarantee
they’ll be executed promptly [JLS, 12.6]. It can take arbitrarily long between
the time that an object becomes unreachable and the time its finalizer or
cleaner runs. This means that you should never do anything time-critical in
a finalizer or cleaner. For example, it is a grave error to depend on a
finalizer or cleaner to close files because open file descriptors are a limited
resource. If many files are left open as a result of the system’s tardiness in
running finalizers or cleaners, a program may fail because it can no longer
open files.
The promptness with which finalizers and cleaners are executed is
primarily a function of the garbage collection algorithm, which varies widely
across implementations. The behavior of a program that depends on the
promptness of finalizer or cleaner execution may likewise vary. It is entirely
possible that such a program will run perfectly on the JVM on which you test
it and then fail miserably on the one favored by your most important
customer.
Tardy finalization is not just a theoretical problem. Providing a finalizer for
a class can arbitrarily delay reclamation of its instances. A colleague
debugged a long-running GUI application that was mysteriously dying with
an OutOfMemoryError. Analysis revealed that at the time of its death, the
application had thousands of graphics objects on its finalizer queue just
waiting to be finalized and reclaimed. Unfortunately, the finalizer thread was
running at a lower priority than another application thread, so objects weren’t
getting finalized at the rate they became eligible for finalization. The
language specification makes no guarantees as to which thread will execute
finalizers, so there is no portable way to prevent this sort of problem other
than to refrain from using finalizers. Cleaners are a bit better than finalizers in
this regard because class authors have control over their own cleaner threads,
49
but cleaners still run in the background, under the control of the garbage
collector, so there can be no guarantee of prompt cleaning.
Not only does the specification provide no guarantee that finalizers or
cleaners will run promptly; it provides no guarantee that they’ll run at all. It is
entirely possible, even likely, that a program terminates without running them
on some objects that are no longer reachable. As a consequence, you should
never depend on a finalizer or cleaner to update persistent state. For
example, depending on a finalizer or cleaner to release a persistent lock on a
shared resource such as a database is a good way to bring your entire
distributed system to a grinding halt.
Don’t be seduced by the methods System.gc and
System.runFinalization. They may increase the odds of finalizers or
cleaners getting executed, but they don’t guarantee it. Two methods once
claimed to make this guarantee: System.runFinalizersOnExit and
its evil twin, Runtime.runFinalizersOnExit. These methods are
fatally flawed and have been deprecated for decades [ThreadStop].
Another problem with finalizers is that an uncaught exception thrown
during finalization is ignored, and finalization of that object terminates [JLS,
12.6]. Uncaught exceptions can leave other objects in a corrupt state. If
another thread attempts to use such a corrupted object, arbitrary
nondeterministic behavior may result. Normally, an uncaught exception will
terminate the thread and print a stack trace, but not if it occurs in a finalizer—
it won’t even print a warning. Cleaners do not have this problem because a
library using a cleaner has control over its thread.
There is a severe performance penalty for using finalizers and cleaners.
On my machine, the time to create a simple AutoCloseable object, to
close it using try-with-resources, and to have the garbage collector reclaim it
is about 12 ns. Using a finalizer instead increases the time to 550 ns. In other
words, it is about 50 times slower to create and destroy objects with finalizers.
This is primarily because finalizers inhibit efficient garbage collection.
Cleaners are comparable in speed to finalizers if you use them to clean all
instances of the class (about 500 ns per instance on my machine), but cleaners
are much faster if you use them only as a safety net, as discussed below.
Under these circumstances, creating, cleaning, and destroying an object takes
about 66 ns on my machine, which means you pay a factor of five (not fifty)
for the insurance of a safety net if you don’t use it.
Finalizers have a serious security problem: they open your class up to
finalizer attacks. The idea behind a finalizer attack is simple: If an exception
is thrown from a constructor or its serialization equivalents—the
readObject and readResolve methods (Chapter 12)—the finalizer of a
malicious subclass can run on the partially constructed object that should have
50
“died on the vine.” This finalizer can record a reference to the object in a
static field, preventing it from being garbage collected. Once the malformed
object has been recorded, it is a simple matter to invoke arbitrary methods on
this object that should never have been allowed to exist in the first place.
Throwing an exception from a constructor should be sufficient to prevent
an object from coming into existence; in the presence of finalizers, it is
not. Such attacks can have dire consequences. Final classes are immune to
finalizer attacks because no one can write a malicious subclass of a final
class. To protect nonfinal classes from finalizer attacks, write a final
finalize method that does nothing.
So what should you do instead of writing a finalizer or cleaner for a class
whose objects encapsulate resources that require termination, such as files or
threads? Just have your class implement AutoCloseable, and require its
clients to invoke the close method on each instance when it is no longer
needed, typically using try-with-resources to ensure termination even in the
face of exceptions (Item 9). One detail worth mentioning is that the instance
must keep track of whether it has been closed: the close method must
record in a field that the object is no longer valid, and other methods must
check this field and throw an IllegalStateException if they are
called after the object has been closed.
So what, if anything, are cleaners and finalizers good for? They have
perhaps two legitimate uses. One is to act as a safety net in case the owner of
a resource neglects to call its close method. While there’s no guarantee that
the cleaner or finalizer will run promptly (or at all), it is better to free the
resource late than never if the client fails to do so. If you’re considering
writing such a safety-net finalizer, think long and hard about whether the
protection is worth the cost. Some Java library classes, such as
FileInputStream, FileOutputStream, ThreadPoolExecutor,
and java.sql.Connection, have finalizers that serve as safety nets.
A second legitimate use of cleaners concerns objects with native peers. A
native peer is a native (non-Java) object to which a normal object delegates
via native methods. Because a native peer is not a normal object, the garbage
collector doesn’t know about it and can’t reclaim it when its Java peer is
reclaimed. A cleaner or finalizer may be an appropriate vehicle for this task,
assuming the performance is acceptable and the native peer holds no critical
resources. If the performance is unacceptable or the native peer holds
resources that must be reclaimed promptly, the class should have a close
method, as described earlier.
Cleaners are a bit tricky to use. Below is a simple Room class
demonstrating the facility. Let’s assume that rooms must be cleaned before
they are reclaimed. The Room class implements AutoCloseable; the fact
51
that its automatic cleaning safety net uses a cleaner is merely an
implementation detail. Unlike finalizers, cleaners do not pollute a class’s
public API:
Click here to view code image
// An autocloseable class using a cleaner as a safety
net
public class Room implements AutoCloseable {
private static final Cleaner cleaner =
Cleaner.create();
// Resource that requires cleaning. Must not refer
to Room!
private static class State implements Runnable {
int numJunkPiles; // Number of junk piles in
this room
State(int numJunkPiles) {
this.numJunkPiles = numJunkPiles;
}
// Invoked by close method or cleaner
@Override public void run() {
System.out.println("Cleaning room");
numJunkPiles = 0;
}
}
// The state of this room, shared with our cleanable
private final State state;
// Our cleanable. Cleans the room when it’s eligible
for gc
private final Cleaner.Cleanable cleanable;
public Room(int numJunkPiles) {
state = new State(numJunkPiles);
cleanable = cleaner.register(this, state);
}
@Override public void close() {
cleanable.clean();
}
}
The static nested State class holds the resources that are required by the
cleaner to clean the room. In this case, it is simply the numJunkPiles field,
52
which represents the amount of mess in the room. More realistically, it might
be a final long that contains a pointer to a native peer. State implements
Runnable, and its run method is called at most once, by the Cleanable
that we get when we register our State instance with our cleaner in the
Room constructor. The call to the run method will be triggered by one of two
things: Usually it is triggered by a call to Room’s close method calling
Cleanable’s clean method. If the client fails to call the close method by
the time a Room instance is eligible for garbage collection, the cleaner will
(hopefully) call State’s run method.
It is critical that a State instance does not refer to its Room instance. If it
did, it would create a circularity that would prevent the Room instance from
becoming eligible for garbage collection (and from being automatically
cleaned). Therefore, State must be a static nested class because nonstatic
nested classes contain references to their enclosing instances (Item 24). It is
similarly inadvisable to use a lambda because they can easily capture
references to enclosing objects.
As we said earlier, Room’s cleaner is used only as a safety net. If clients
surround all Room instantiations in try-with-resource blocks, automatic
cleaning will never be required. This well-behaved client demonstrates that
behavior:
Click here to view code image
public class Adult {
public static void main(String[] args) {
try (Room myRoom = new Room(7)) {
System.out.println("Goodbye");
}
}
}
As you’d expect, running the Adult program prints Goodbye, followed by
Cleaning room. But what about this ill-behaved program, which never
cleans its room?
Click here to view code image
public class Teenager {
public static void main(String[] args) {
new Room(99);
System.out.println("Peace out");
}
}
You might expect it to print Peace out, followed by Cleaning room,
but on my machine, it never prints Cleaning room; it just exits. This is
53
the unpredictability we spoke of earlier. The Cleaner spec says, “The
behavior of cleaners during System.exit is implementation specific. No
guarantees are made relating to whether cleaning actions are invoked or not.”
While the spec does not say it, the same holds true for normal program exit.
On my machine, adding the line System.gc() to Teenager’s main
method is enough to make it print Cleaning room prior to exit, but there’s
no guarantee that you’ll see the same behavior on your machine.
In summary, don’t use cleaners, or in releases prior to Java 9, finalizers,
except as a safety net or to terminate noncritical native resources. Even then,
beware the indeterminacy and performance consequences.
Item 9: Prefer try-with-resources to try-finally
The Java libraries include many resources that must be closed manually by
invoking a close method. Examples include InputStream,
OutputStream, and java.sql.Connection. Closing resources is
often overlooked by clients, with predictably dire performance consequences.
While many of these resources use finalizers as a safety net, finalizers don’t
work very well (Item 8).
Historically, a try-finally statement was the best way to guarantee that
a resource would be closed properly, even in the face of an exception or
return:
Click here to view code image
// try-finally - No longer the best way to close
resources!
static String firstLineOfFile(String path) throws
IOException {
BufferedReader br = new BufferedReader(new
FileReader(path));
try {
return br.readLine();
} finally {
br.close();
}
}
This may not look bad, but it gets worse when you add a second resource:
Click here to view code image
// try-finally is ugly when used with more than one
resource!
static void copy(String src, String dst) throws
IOException {
54
InputStream in = new FileInputStream(src);
try {
OutputStream out = new FileOutputStream(dst);
try {
byte[] buf = new byte[BUFFER_SIZE];
int n;
while ((n = in.read(buf)) >= 0)
out.write(buf, 0, n);
} finally {
out.close();
}
} finally {
in.close();
}
}
It may be hard to believe, but even good programmers got this wrong most
of the time. For starters, I got it wrong on page 88 of Java Puzzlers
[Bloch05], and no one noticed for years. In fact, two-thirds of the uses of the
close method in the Java libraries were wrong in 2007.
Even the correct code for closing resources with try-finally
statements, as illustrated in the previous two code examples, has a subtle
deficiency. The code in both the try block and the finally block is
capable of throwing exceptions. For example, in the firstLineOfFile
method, the call to readLine could throw an exception due to a failure in
the underlying physical device, and the call to close could then fail for the
same reason. Under these circumstances, the second exception completely
obliterates the first one. There is no record of the first exception in the
exception stack trace, which can greatly complicate debugging in real systems
—usually it’s the first exception that you want to see in order to diagnose the
problem. While it is possible to write code to suppress the second exception
in favor of the first, virtually no one did because it’s just too verbose.
All of these problems were solved in one fell swoop when Java 7
introduced the try-with-resources statement [JLS, 14.20.3]. To be usable
with this construct, a resource must implement the AutoCloseable
interface, which consists of a single void-returning close method. Many
classes and interfaces in the Java libraries and in third-party libraries now
implement or extend AutoCloseable. If you write a class that represents a
resource that must be closed, your class should implement AutoCloseable
too.
Here’s how our first example looks using try-with-resources:
Click here to view code image
// try-with-resources - the the best way to close
55
resources!
static String firstLineOfFile(String path) throws
IOException {
try (BufferedReader br = new BufferedReader(
new FileReader(path))) {
return br.readLine();
}
}
And here’s how our second example looks using try-with-resources:
Click here to view code image
// try-with-resources on multiple resources - short and
sweet
static void copy(String src, String dst) throws
IOException {
try (InputStream in = new FileInputStream(src);
OutputStream out = new FileOutputStream(dst)) {
byte[] buf = new byte[BUFFER_SIZE];
int n;
while ((n = in.read(buf)) >= 0)
out.write(buf, 0, n);
}
}
Not only are the try-with-resources versions shorter and more readable than
the originals, but they provide far better diagnostics. Consider the
firstLineOfFile method. If exceptions are thrown by both the
readLine call and the (invisible) close, the latter exception is suppressed
in favor of the former. In fact, multiple exceptions may be suppressed in order
to preserve the exception that you actually want to see. These suppressed
exceptions are not merely discarded; they are printed in the stack trace with a
notation saying that they were suppressed. You can also access them
programmatically with the getSuppressed method, which was added to
Throwable in Java 7.
You can put catch clauses on try-with-resources statements, just as you
can on regular try-finally statements. This allows you to handle
exceptions without sullying your code with another layer of nesting. As a
slightly contrived example, here’s a version our firstLineOfFile
method that does not throw exceptions, but takes a default value to return if it
can’t open the file or read from it:
Click here to view code image
// try-with-resources with a catch clause
static String firstLineOfFile(String path, String
56
defaultVal) {
try (BufferedReader br = new BufferedReader(
new FileReader(path))) {
return br.readLine();
} catch (IOException e) {
return defaultVal;
}
}
The lesson is clear: Always use try-with-resources in preference to tryfinally when working with resources that must be closed. The resulting
code is shorter and clearer, and the exceptions that it generates are more
useful. The try-with-resources statement makes it easy to write correct code
using resources that must be closed, which was practically impossible using
try-finally.
57
Chapter 3. Methods Common to All
Objects
ALTHOUGH Object is a concrete class, it is designed primarily for extension.
All of its nonfinal methods (equals, hashCode, toString, clone, and
finalize) have explicit general contracts because they are designed to be
overridden. It is the responsibility of any class overriding these methods to
obey their general contracts; failure to do so will prevent other classes that
depend on the contracts (such as HashMap and HashSet) from functioning
properly in conjunction with the class.
This chapter tells you when and how to override the nonfinal Object
methods. The finalize method is omitted from this chapter because it was
discussed in Item 8. While not an Object method,
Comparable.compareTo is discussed in this chapter because it has a
similar character.
Item 10: Obey the general contract when overriding
equals
Overriding the equals method seems simple, but there are many ways to get
it wrong, and consequences can be dire. The easiest way to avoid problems is
not to override the equals method, in which case each instance of the class
is equal only to itself. This is the right thing to do if any of the following
conditions apply:
• Each instance of the class is inherently unique. This is true for classes
such as Thread that represent active entities rather than values. The
equals implementation provided by Object has exactly the right
behavior for these classes.
• There is no need for the class to provide a “logical equality” test. For
example, java.util.regex.Pattern could have overridden
equals to check whether two Pattern instances represented exactly
the same regular expression, but the designers didn’t think that clients
would need or want this functionality. Under these circumstances, the
equals implementation inherited from Object is ideal.
• A superclass has already overridden equals, and the superclass
behavior is appropriate for this class. For example, most Set
58
implementations inherit their equals implementation from
AbstractSet, List implementations from AbstractList, and
Map implementations from AbstractMap.
• The class is private or package-private, and you are certain that its
equals method will never be invoked. If you are extremely riskaverse, you can override the equals method to ensure that it isn’t
invoked accidentally:
Click here to view code image
@Override public boolean equals(Object o) {
throw new AssertionError(); // Method is never
called
}
So when is it appropriate to override equals? It is when a class has a
notion of logical equality that differs from mere object identity and a
superclass has not already overridden equals. This is generally the case for
value classes. A value class is simply a class that represents a value, such as
Integer or String. A programmer who compares references to value
objects using the equals method expects to find out whether they are
logically equivalent, not whether they refer to the same object. Not only is
overriding the equals method necessary to satisfy programmer
expectations, it enables instances to serve as map keys or set elements with
predictable, desirable behavior.
One kind of value class that does not require the equals method to be
overridden is a class that uses instance control (Item 1) to ensure that at most
one object exists with each value. Enum types (Item 34) fall into this
category. For these classes, logical equality is the same as object identity, so
Object’s equals method functions as a logical equals method.
When you override the equals method, you must adhere to its general
contract. Here is the contract, from the specification for Object :
The equals method implements an equivalence relation. It has these
properties:
• Reflexive: For any non-null reference value x, x.equals(x) must
return true.
• Symmetric: For any non-null reference values x and y, x.equals(y)
must return true if and only if y.equals(x) returns true.
• Transitive: For any non-null reference values x, y, z, if x.equals(y)
returns true and y.equals(z) returns true, then x.equals(z)
59
must return true.
• Consistent: For any non-null reference values x and y, multiple
invocations of x.equals(y) must consistently return true or
consistently return false, provided no information used in equals
comparisons is modified.
• For any non-null reference value x, x.equals(null) must return
false.
Unless you are mathematically inclined, this might look a bit scary, but do
not ignore it! If you violate it, you may well find that your program behaves
erratically or crashes, and it can be very difficult to pin down the source of the
failure. To paraphrase John Donne, no class is an island. Instances of one
class are frequently passed to another. Many classes, including all collections
classes, depend on the objects passed to them obeying the equals contract.
Now that you are aware of the dangers of violating the equals contract,
let’s go over the contract in detail. The good news is that, appearances
notwithstanding, it really isn’t very complicated. Once you understand it, it’s
not hard to adhere to it.